package cn.ussshenzhou.t88.network;

import cn.ussshenzhou.t88.network.annotation.*;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * @author USS_Shenzhou
 */
@SupportedAnnotationTypes({"cn.ussshenzhou.t88.network.annotation.NetPacket", "cn.ussshenzhou.t88.network.annotation.Encoder",
        "cn.ussshenzhou.t88.network.annotation.Decoder", "cn.ussshenzhou.t88.network.annotation.ClientHandler", "cn.ussshenzhou.t88.network.annotation.ServerHandler"})
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class NetworkAnnotationProcessor extends AbstractProcessor {
    private static final String PROXY_CLASS_SUFFIX = "$Generated";
    private static final String GENERATED_PACKAGE_SUFFIX = ".generated";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> sources = roundEnv.getElementsAnnotatedWith(NetPacket.class);
        if (sources.isEmpty()) {
            return true;
        }
        implementCustomPacketPayload(sources);
        generateRegistry(sources);
        return true;
    }

    private void implementCustomPacketPayload(Set<? extends Element> sources) {
        sources.forEach(element -> {
            try {
                TypeElement originalClass = (TypeElement) element;
                var originalClassName = originalClass.getSimpleName().toString();
                var packageName = processingEnv.getElementUtils().getPackageOf(originalClass).getQualifiedName().toString();
                JavaFileObject proxyClass = processingEnv.getFiler().createSourceFile("t88.packets." + originalClassName + PROXY_CLASS_SUFFIX, originalClass);
                PrintWriter registryWriter = new PrintWriter(proxyClass.openWriter());
                NetPacket netPacket = originalClass.getAnnotation(NetPacket.class);
                var proxyClassCode = String.format("""
                                // Automatically generated by cn.ussshenzhou.t88.network.NetworkAnnotationProcessor
                                package %1$s;
                                                                
                                import net.minecraft.network.FriendlyByteBuf;
                                                                
                                public class %2$s extends %3$s.%4$s implements net.minecraft.network.protocol.common.custom.CustomPacketPayload {
                                                                
                                    public %2$s(FriendlyByteBuf buf) {
                                        super(buf);
                                    }
                                                                
                                    public static final net.minecraft.resources.ResourceLocation ID = new net.minecraft.resources.ResourceLocation("%5$s", "%6$s");
                                                                
                                    @Override
                                    public net.minecraft.resources.ResourceLocation id() {
                                        return ID;
                                    }
                                                                
                                }
                                """,
                        packageName + GENERATED_PACKAGE_SUFFIX,
                        originalClassName + PROXY_CLASS_SUFFIX,
                        packageName,
                        originalClassName,
                        netPacket.modid(),
                        originalClassName.toLowerCase()
                );
                registryWriter.println(proxyClassCode);
                registryWriter.close();
            } catch (IOException e) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "T88 #implementCustomPacketPayload Error:");
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
            }
        });
    }

    private void generateRegistry(Set<? extends Element> sources) {
        try {
            TypeElement anySourceClass = (TypeElement) sources.toArray()[0];
            String anySourceClassName = anySourceClass.getQualifiedName().toString();
            String thisPackageName = anySourceClassName.substring(0, anySourceClassName.lastIndexOf(".")) + GENERATED_PACKAGE_SUFFIX;
            JavaFileObject registry = processingEnv.getFiler().createSourceFile("t88.ModNetworkRegistry", anySourceClass);
            PrintWriter registryWriter = new PrintWriter(registry.openWriter());
            registryWriter.println(String.format("""
                    // Automatically generated by cn.ussshenzhou.t88.network.NetworkAnnotationProcessor
                    package %s;
                        
                    import com.mojang.logging.LogUtils;
                    import net.neoforged.bus.api.SubscribeEvent;
                    import net.neoforged.fml.common.Mod;
                    import net.neoforged.neoforge.network.event.RegisterPayloadHandlerEvent;
                    import net.neoforged.neoforge.network.registration.IPayloadRegistrar;
                    """, thisPackageName));
            registryWriter.println("""
                                        
                    @Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)
                    public class ModNetworkRegistry {
                        @SubscribeEvent
                        public static void networkPacketRegistry(RegisterPayloadHandlerEvent event) {
                    """);
            Map<String, LinkedList<TypeElement>> packetGroupedByModId = new HashMap<>();
            sources.forEach(element -> {
                TypeElement sourceClass = (TypeElement) element;
                NetPacket netPacket = sourceClass.getAnnotation(NetPacket.class);
                packetGroupedByModId.compute(netPacket.modid(), (modId, elementList) -> Objects.requireNonNullElseGet(elementList, LinkedList::new)).add(sourceClass);
            });
            packetGroupedByModId.forEach((modId, elementList) -> {
                var registrarName = "registrar$" + modId;
                registryWriter.println(String.format("""
                                final IPayloadRegistrar %s = event.registrar("%s");
                        """, registrarName, modId));
                elementList.forEach(sourceClass -> {
                    var sourceClassName = sourceClass.getSimpleName().toString();
                    var proxyClassName = sourceClassName + PROXY_CLASS_SUFFIX;
                    var packageName = processingEnv.getElementUtils().getPackageOf(sourceClass).getQualifiedName().toString();
                    String clientHandlerName = null;
                    String serverHandlerName = null;
                    String decoderName = null;
                    for (Element element : sourceClass.getEnclosedElements()) {
                        if (element.getAnnotation(ClientHandler.class) != null) {
                            clientHandlerName = element.getSimpleName().toString();
                        } else if (element.getAnnotation(ServerHandler.class) != null) {
                            serverHandlerName = element.getSimpleName().toString();
                        } else if (element.getAnnotation(Decoder.class) != null) {
                            if (element.getKind() == ElementKind.CONSTRUCTOR) {
                                decoderName = "new";
                            } else {
                                decoderName = element.getSimpleName().toString();
                            }
                        }
                    }
                    if (clientHandlerName == null || serverHandlerName == null || decoderName == null) {
                        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                "Failed to get valid method name. @NetPacket class = " + sourceClassName
                                        + ", @ClientHandler = " + clientHandlerName
                                        + ", @ServerHandler = " + serverHandlerName
                                        + ", @Decoder = " + decoderName
                        );
                        return;
                    }
                    registryWriter.println(String.format("""
                                            %4$s.play(%1$s.ID, %1$s::%5$s,
                                                    handler -> handler
                                                            .client((payload, context) -> context.workHandler().submitAsync(() -> payload.%2$s(context)))
                                                            .server((payload, context) -> context.workHandler().submitAsync(() -> payload.%3$s(context)))
                                            );
                                            try {
                                                cn.ussshenzhou.t88.network.NetworkHelper.register(Class.forName("%6$s"), Class.forName("%1$s"));
                                            } catch (ClassNotFoundException e) {
                                                LogUtils.getLogger().error("T88 failed to register < %6$s, %1$s >");
                                                throw new RuntimeException(e);
                                            }
                                    """,
                            packageName + GENERATED_PACKAGE_SUFFIX + "." + proxyClassName,
                            clientHandlerName,
                            serverHandlerName,
                            registrarName,
                            decoderName,
                            packageName + "." + sourceClassName
                    ));
                });
            });
            registryWriter.println("""
                        }
                    }
                    """);
            registryWriter.close();
        } catch (IOException ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "T88 #generateRegistry Error:");
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.getMessage());
        }
    }

}
