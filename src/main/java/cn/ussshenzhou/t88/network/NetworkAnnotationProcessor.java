package cn.ussshenzhou.t88.network;

import cn.ussshenzhou.t88.network.annotation.*;
import net.minecraft.resources.ResourceLocation;
import net.neoforged.neoforge.network.registration.IPayloadRegistrar;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * @author USS_Shenzhou
 */
@SupportedAnnotationTypes({"cn.ussshenzhou.t88.network.annotation.NetPacket", "cn.ussshenzhou.t88.network.annotation.Encoder",
        "cn.ussshenzhou.t88.network.annotation.Decoder", "cn.ussshenzhou.t88.network.annotation.ClientHandler", "cn.ussshenzhou.t88.network.annotation.ServerHandler"})
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class NetworkAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Set<? extends Element> sources = roundEnv.getElementsAnnotatedWith(NetPacket.class);
        if (sources.isEmpty()) {
            return true;
        }
        implementCustomPacketPayload(sources);
        generateRegistry(sources);
        return true;
    }

    private void implementCustomPacketPayload(Set<? extends Element> sources) {
        sources.forEach(element -> {
            try {
                TypeElement originalClass = (TypeElement) element;
                String originalClassName = originalClass.getSimpleName().toString();
                JavaFileObject implementedClass = processingEnv.getFiler().createSourceFile("t88.packets." + originalClassName, originalClass);
                PrintWriter registryWriter = new PrintWriter(implementedClass.openWriter());
                var packageName = processingEnv.getElementUtils().getPackageOf(originalClass).getQualifiedName().toString();
                StringBuilder code = new StringBuilder(String.format("""
                        // Automatically generated by cn.ussshenzhou.t88.network.NetworkAnnotationProcessor
                        package %s;
                        """, packageName + ".generated"));
                //read existing codes
                File originalClassFile = new File("src/main/java/" + packageName.replace('.', '/') + "/" + originalClassName + ".java");
                InputStream originalInputStream = new FileInputStream(originalClassFile);
                BufferedReader reader = new BufferedReader(new InputStreamReader(originalInputStream, StandardCharsets.UTF_8));
                String line;
                while ((line = reader.readLine()) != null) {
                    if (line.startsWith("package ")|| line.startsWith("@NetPacket")||line.startsWith("@cn.ussshenzhou.t88.network.annotation.NetPacket")) {
                        continue;
                    }
                    code.append(line).append("\n");
                }
                reader.close();
                //check encoder name
                for (Element e : originalClass.getEnclosedElements()) {
                    if (e.getAnnotation(Encoder.class) != null) {
                        var encoderName = e.getSimpleName().toString();
                        if (!"write".equals(encoderName)) {
                            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                    "Illegal @Encoder method name of class " + originalClassName + ". It must be 'write'.");
                        }
                    }
                }
                //implement CustomPacketPayload
                code.insert(code.indexOf("{"), "implements net.minecraft.network.protocol.common.custom.CustomPacketPayload ");
                NetPacket netPacket = originalClass.getAnnotation(NetPacket.class);
                code.insert(code.lastIndexOf("}") - 1, String.format("""
                            
                            public static final net.minecraft.resources.ResourceLocation ID = new net.minecraft.resources.ResourceLocation("%1$s", "%2$s");
                            
                            @Override
                            public net.minecraft.resources.ResourceLocation id() {
                                return ID;
                            }
                        """, netPacket.modid(), originalClass.getSimpleName().toString().toLowerCase()));
                registryWriter.println(code);
                registryWriter.close();
            } catch (IOException e) {
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "T88 #implementCustomPacketPayload Error:");
                processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage());
            }
        });
    }

    private void generateRegistry(Set<? extends Element> sources) {
        try {
            TypeElement anySourceClass = (TypeElement) sources.toArray()[0];
            String anySourceClassName = anySourceClass.getQualifiedName().toString();
            String packageName = anySourceClassName.substring(0, anySourceClassName.lastIndexOf(".")) + ".generated";
            JavaFileObject registry = processingEnv.getFiler().createSourceFile("t88.ModNetworkRegistry", anySourceClass);
            PrintWriter registryWriter = new PrintWriter(registry.openWriter());
            registryWriter.println(String.format("""
                    // Automatically generated by cn.ussshenzhou.t88.network.NetworkAnnotationProcessor
                    package %s;
                        
                    import net.neoforged.bus.api.SubscribeEvent;
                    import net.neoforged.fml.common.Mod;
                    import net.neoforged.neoforge.network.event.RegisterPayloadHandlerEvent;
                    import net.neoforged.neoforge.network.registration.IPayloadRegistrar;
                    """, packageName));
            sources.forEach(element -> {
                TypeElement sourceClass = (TypeElement) element;
                registryWriter.println("import " + processingEnv.getElementUtils().getPackageOf(sourceClass).getQualifiedName().toString() + ".generated." + sourceClass.getSimpleName() + ";");
            });
            registryWriter.println("""
                                        
                    @Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)
                    public class ModNetworkRegistry {
                        @SubscribeEvent
                        public static void networkPacketRegistry(RegisterPayloadHandlerEvent event) {
                    """);
            Map<String, LinkedList<TypeElement>> packetGroupedByModId = new HashMap<>();
            sources.forEach(element -> {
                TypeElement sourceClass = (TypeElement) element;
                NetPacket netPacket = sourceClass.getAnnotation(NetPacket.class);
                packetGroupedByModId.compute(netPacket.modid(), (modId, elementList) -> Objects.requireNonNullElseGet(elementList, LinkedList::new)).add(sourceClass);
            });
            packetGroupedByModId.forEach((modId, elementList) -> {
                var registrarName = "registrar$" + modId;
                registryWriter.println(String.format("""
                                final IPayloadRegistrar %s = event.registrar("%s");
                        """, registrarName, modId));
                elementList.forEach(sourceClass -> {
                    String sourceClassName = sourceClass.getSimpleName().toString();
                    NetPacket netPacket = sourceClass.getAnnotation(NetPacket.class);
                    String clientHandlerName = null;
                    String serverHandlerName = null;
                    String decoderName = null;
                    for (Element element : sourceClass.getEnclosedElements()) {
                        if (element.getAnnotation(ClientHandler.class) != null) {
                            clientHandlerName = element.getSimpleName().toString();
                        } else if (element.getAnnotation(ServerHandler.class) != null) {
                            serverHandlerName = element.getSimpleName().toString();
                        } else if (element.getAnnotation(Decoder.class) != null) {
                            if (element.getKind() == ElementKind.CONSTRUCTOR) {
                                decoderName = "new";
                            } else {
                                decoderName = element.getSimpleName().toString();
                            }
                        }
                    }
                    if (clientHandlerName == null || serverHandlerName == null || decoderName == null) {
                        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
                                "Failed to get valid method name. @NetPacket class = " + sourceClassName
                                        + ", @ClientHandler = " + clientHandlerName
                                        + ", @ServerHandler = " + serverHandlerName
                                        + ", @Decoder = " + decoderName
                        );
                        return;
                    }
                    registryWriter.println(String.format("""
                                    %4$s.play(%1$s.ID, %1$s::%5$s,
                                            handler -> handler
                                                    .client((payload, context) -> context.workHandler().submitAsync(() -> payload.%2$s(context)))
                                                    .server((payload, context) -> context.workHandler().submitAsync(() -> payload.%3$s(context)))
                                    );
                            """, sourceClassName, clientHandlerName, serverHandlerName, registrarName, decoderName));

                });
            });
            registryWriter.println("""
                        }
                    }
                    """);
            registryWriter.close();
        } catch (IOException ex) {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, "T88 #generateRegistry Error:");
            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, ex.getMessage());
        }
    }

}
